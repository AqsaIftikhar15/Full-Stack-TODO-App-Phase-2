import asyncio
import json
import os
from datetime import datetime, timedelta
from contextlib import asynccontextmanager
from typing import Dict, Any

import uvicorn
from fastapi import FastAPI

from dapr.ext.fastapi import DaprApp
from dapr.clients import DaprClient


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print("Starting Recurring Task Service...")
    yield
    # Shutdown
    print("Shutting down Recurring Task Service...")


app = FastAPI(
    title="Recurring Task Service",
    description="Service to handle recurring tasks and generate new task instances",
    lifespan=lifespan
)

# Wrap the app with Dapr extension
dapr_app = DaprApp(app)


@dapr_app.subscribe(pubsub_name='kafka-pubsub', topic='task-events')
async def handle_task_events(event_data: dict) -> None:
    """
    Handle task events from Kafka via Dapr pubsub to detect recurring tasks
    """
    print(f"Received task event in recurring task service: {event_data}")
    
    # Extract event details
    event_type = event_data.get("eventType", "")
    task_data = event_data.get("taskData", {})
    
    # Only process 'created' events for recurring tasks
    if event_type == "created":
        recurrence_rule = task_data.get("recurrenceRule", {})
        
        if recurrence_rule and recurrence_rule.get("enabled", False):
            print(f"Detected recurring task: {task_data.get('title', 'Unknown')}")
            # Process the recurring task to generate next instances
            await process_recurring_task(task_data)


async def process_recurring_task(task_data: Dict[str, Any]):
    """
    Process a recurring task and generate the next task instance
    """
    print(f"Processing recurring task: {task_data.get('title', 'Unknown')}")
    
    # Extract recurrence rule
    recurrence_rule = task_data.get("recurrenceRule", {})
    pattern = recurrence_rule.get("pattern", "daily")
    interval_days = recurrence_rule.get("intervalDays", 1)
    ends_on = recurrence_rule.get("endsOn")
    occurrences_count = recurrence_rule.get("occurrencesCount")
    
    # Get the due date of the current task
    current_due_date_str = task_data.get("dueDate")
    if not current_due_date_str:
        print("No due date found for the task, skipping recurrence processing")
        return
    
    # Calculate the next due date based on the recurrence pattern
    current_due_date = datetime.fromisoformat(current_due_date_str.replace('Z', '+00:00'))
    
    if pattern == "daily":
        next_due_date = current_due_date + timedelta(days=interval_days)
    elif pattern == "weekly":
        next_due_date = current_due_date + timedelta(weeks=interval_days)
    elif pattern == "monthly":
        # Simple monthly calculation (adding ~30 days)
        next_due_date = current_due_date + timedelta(days=interval_days * 30)
    elif pattern == "interval":
        next_due_date = current_due_date + timedelta(days=interval_days)
    else:
        print(f"Unsupported recurrence pattern: {pattern}")
        return
    
    # Check if we've reached the end condition
    if ends_on:
        ends_on_date = datetime.fromisoformat(ends_on.replace('Z', '+00:00'))
        if next_due_date > ends_on_date:
            print("Recurring task has reached its end date, stopping generation")
            return
    
    # For occurrence count, we would need to track how many instances have been created
    # This would require a separate persistence mechanism
    
    # Create a new task instance with the next due date
    new_task_data = {
        "title": task_data.get("title", ""),
        "description": task_data.get("description", ""),
        "userId": task_data.get("userId", ""),
        "priority": task_data.get("priority", "medium"),
        "tags": task_data.get("tags", []),
        "dueDate": next_due_date.isoformat(),
        "reminderConfig": task_data.get("reminderConfig"),
        "recurrenceRule": recurrence_rule,  # Carry over the recurrence rule
        "status": "pending"
    }
    
    # Publish an event to create the new recurring task instance
    try:
        async with DaprClient() as client:
            # Publish event to create the new task instance
            await client.publish_event(
                pubsub_name='kafka-pubsub',
                topic='task-events',
                data=json.dumps({
                    "eventType": "created",
                    "taskId": "",  # Will be generated by the backend
                    "userId": task_data.get("userId", ""),
                    "taskData": new_task_data
                }),
                data_content_type='application/json'
            )
            print(f"New recurring task instance scheduled for {next_due_date}")
    except Exception as e:
        print(f"Error publishing recurring task event: {str(e)}")


@app.get("/")
async def read_root():
    return {"status": "Recurring Task Service is running"}

@app.get("/health")
async def health_check():
    # Check if Dapr sidecar is accessible
    try:
        async with DaprClient() as client:
            # Try to communicate with Dapr
            await client.wait(5)  # Wait up to 5 seconds for Dapr to be ready
        dapr_status = "healthy"
    except Exception as e:
        dapr_status = f"unhealthy: {str(e)}"
    
    return {
        "status": "healthy",
        "checks": {
            "dapr_sidecar": dapr_status,
            "subscription_status": "active"
        }
    }


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8004, reload=True)